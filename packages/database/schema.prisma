// Prisma schema for scleorg

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User model (minimal - most data managed by Clerk)
model User {
  id                   String    @id @default(uuid())
  clerkId              String    @unique @map("clerk_id")
  email                String
  companyName          String?   @map("company_name")
  industry             String?
  companySize          String?   @map("company_size")
  onboardingCompleted  Boolean   @default(false) @map("onboarding_completed")
  createdAt            DateTime  @default(now()) @map("created_at")
  updatedAt            DateTime  @updatedAt @map("updated_at")

  // Relations
  datasets          Dataset[]

  @@index([clerkId])
  @@index([email])
  @@map("users")
}

// Dataset model
model Dataset {
  id              String    @id @default(uuid())
  userId          String    @map("user_id")
  organizationId  String?   @map("organization_id")  // Clerk organization ID

  // Metadata
  name            String
  description     String?
  status          DatasetStatus @default(PROCESSING)

  // Upload info
  fileName        String    @map("file_name")
  fileUrl         String    @map("file_url")
  fileSizeBytes   Int?      @map("file_size_bytes")
  fileType        String    @map("file_type")

  // Column mapping (JSON)
  columnMapping   Json?     @map("column_mapping")

  // Organization metadata
  companyName       String?   @map("company_name")
  totalRevenue      Decimal?  @map("total_revenue") @db.Decimal(15, 2)
  currentCashBalance Decimal? @map("current_cash_balance") @db.Decimal(15, 2)  // Cash in bank for runway calculations
  fiscalYearStart   DateTime? @map("fiscal_year_start")
  currency          String    @default("EUR")
  isDemo            Boolean   @default(false) @map("is_demo")  // Demo data flag

  // Timestamps
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")
  processedAt     DateTime? @map("processed_at")

  // Relations
  user                    User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  employees               Employee[]
  openRoles               OpenRole[]
  scenarios               Scenario[]
  insights                Insight[]
  settings                DatasetSettings?
  monthlyEmployerCosts    MonthlyEmployerCost[]
  monthlyPlannedCompensation MonthlyPlannedCompensation[]
  monthlyRevenue          MonthlyRevenue[]
  compensationScenarios   CompensationScenario[]

  @@index([userId])
  @@index([organizationId])
  @@index([status])
  @@index([createdAt(sort: Desc)])
  @@map("datasets")
}

enum DatasetStatus {
  PROCESSING
  MAPPING_REQUIRED
  CALCULATING
  READY
  FAILED
}

// Dataset Settings - per-company customization for analytics
model DatasetSettings {
  id          String   @id @default(uuid())
  datasetId   String   @unique @map("dataset_id")

  // Department categorization mapping
  // JSON structure: { "Engineering": "R&D", "Sales": "GTM", "Finance": "G&A", "IT": "Operations", ... }
  departmentCategories Json? @map("department_categories")

  // Benchmark matching criteria (optional - defaults to user-level settings if not set)
  industry    String?                                  // "SaaS", "Fintech", "Climate Tech", etc.
  region      String?                                  // "DACH", "EU", "US", "Global", etc.
  growthStage String?  @map("growth_stage")           // "Seed", "Series A", "Series B+", "Growth", "Public"

  // KPI preferences - which KPIs to show in dashboard
  // Array of KPI IDs, e.g., ["revenue_per_employee", "eng_pct_employees", ...]
  // If null, shows default KPIs
  selectedKPIs String[] @default([]) @map("selected_kpis")

  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  dataset     Dataset  @relation(fields: [datasetId], references: [id], onDelete: Cascade)

  @@index([datasetId])
  @@index([industry, region])
  @@map("dataset_settings")
}

// Employee model
model Employee {
  id                 String    @id @default(uuid())
  datasetId          String    @map("dataset_id")

  // Identity (optional/anonymizable)
  employeeId         String?   @map("employee_id")
  employeeName       String?   @map("employee_name")
  email              String?

  // Organization structure
  department         String
  role               String?
  level              EmployeeLevel?
  managerId          String?   @map("manager_id")
  costCenter         String?   @map("cost_center")

  // Employment details
  employmentType     EmploymentType @default(FTE) @map("employment_type")
  fteFactor          Decimal   @default(1.0) @map("fte_factor") @db.Decimal(3, 2)
  location           String?
  gender             Gender?                                          // For pay gap analysis

  // Compensation
  annualSalary       Decimal?  @map("annual_salary") @db.Decimal(12, 2)
  bonus              Decimal?  @db.Decimal(12, 2)
  equityValue        Decimal?  @map("equity_value") @db.Decimal(12, 2)
  totalCompensation  Decimal   @map("total_compensation") @db.Decimal(12, 2)

  // Dates
  startDate          DateTime? @map("start_date")
  endDate            DateTime? @map("end_date")

  createdAt          DateTime  @default(now()) @map("created_at")
  updatedAt          DateTime  @updatedAt @map("updated_at")

  // Relations
  dataset                    Dataset   @relation(fields: [datasetId], references: [id], onDelete: Cascade)
  manager                    Employee? @relation("EmployeeManager", fields: [managerId], references: [id])
  directReports              Employee[] @relation("EmployeeManager")
  monthlyEmployerCosts       MonthlyEmployerCost[]
  monthlyPlannedCompensation MonthlyPlannedCompensation[]
  compensationTargets        EmployeeCompensationTarget[]

  @@index([datasetId])
  @@index([datasetId, department])
  @@index([managerId])
  @@index([employmentType])
  @@map("employees")
}

enum EmployeeLevel {
  IC
  MANAGER
  DIRECTOR
  VP
  C_LEVEL
}

enum EmploymentType {
  FTE
  CONTRACTOR
  PART_TIME
  INTERN
}

enum Gender {
  MALE
  FEMALE
  DIVERSE
  PREFER_NOT_TO_SAY
}

// Open roles model
model OpenRole {
  id                  String    @id @default(uuid())
  datasetId           String    @map("dataset_id")

  roleName            String    @map("role_name")
  department          String
  level               EmployeeLevel?

  plannedSalaryMin    Decimal?  @map("planned_salary_min") @db.Decimal(12, 2)
  plannedSalaryMax    Decimal?  @map("planned_salary_max") @db.Decimal(12, 2)
  plannedTotalComp    Decimal?  @map("planned_total_comp") @db.Decimal(12, 2)

  plannedStartDate    DateTime? @map("planned_start_date")
  plannedEndDate      DateTime? @map("planned_end_date")

  status              RoleStatus @default(OPEN)

  createdAt           DateTime  @default(now()) @map("created_at")
  updatedAt           DateTime  @updatedAt @map("updated_at")

  // Relations
  dataset             Dataset   @relation(fields: [datasetId], references: [id], onDelete: Cascade)

  @@index([datasetId])
  @@index([datasetId, department])
  @@index([status])
  @@map("open_roles")
}

enum RoleStatus {
  OPEN
  OFFER_EXTENDED
  FILLED
  CANCELLED
}

// Scenario model
model Scenario {
  id            String    @id @default(uuid())
  datasetId     String    @map("dataset_id")

  name          String
  description   String?
  type          ScenarioType

  // Parameters and operations (JSON)
  parameters    Json
  operations    Json

  // Enhanced timeline data (JSON)
  affectedEmployees Json?  @map("affected_employees")
  monthlyBurnRate   Json?  @map("monthly_burn_rate")
  runway            Json?  @map("runway")
  yearEndProjection Json?  @map("year_end_projection")
  currentCash       Decimal? @map("current_cash") @db.Decimal(15, 2)

  status        ScenarioStatus @default(DRAFT)
  calculatedAt  DateTime?      @map("calculated_at")

  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  // Relations
  dataset       Dataset   @relation(fields: [datasetId], references: [id], onDelete: Cascade)
  results       ScenarioResult[]
  insights      Insight[]

  @@index([datasetId])
  @@index([type])
  @@index([createdAt(sort: Desc)])
  @@map("scenarios")
}

enum ScenarioType {
  HIRING_FREEZE
  COST_REDUCTION
  GROWTH
  TARGET_RATIO
  CUSTOM
}

enum ScenarioStatus {
  DRAFT
  CALCULATED
  ARCHIVED
}

// Scenario results (cached calculations)
model ScenarioResult {
  id          String    @id @default(uuid())
  scenarioId  String    @map("scenario_id")

  metrics     Json
  delta       Json

  createdAt   DateTime  @default(now()) @map("created_at")

  // Relations
  scenario    Scenario  @relation(fields: [scenarioId], references: [id], onDelete: Cascade)

  @@index([scenarioId])
  @@map("scenario_results")
}

// Insights model
model Insight {
  id                String    @id @default(uuid())
  datasetId         String    @map("dataset_id")
  scenarioId        String?   @map("scenario_id")

  ruleId            String?   @map("rule_id")
  category          InsightCategory
  severity          InsightSeverity

  title             String
  description       String

  metrics           Json?
  suggestedActions  Json?     @map("suggested_actions")

  generatedBy       String    @default("rule") @map("generated_by")
  confidenceScore   Decimal?  @map("confidence_score") @db.Decimal(3, 2)

  createdAt         DateTime  @default(now()) @map("created_at")

  // Relations
  dataset           Dataset   @relation(fields: [datasetId], references: [id], onDelete: Cascade)
  scenario          Scenario? @relation(fields: [scenarioId], references: [id], onDelete: Cascade)

  @@index([datasetId])
  @@index([scenarioId])
  @@index([severity])
  @@index([category])
  @@map("insights")
}

enum InsightCategory {
  COST
  STRUCTURE
  EFFICIENCY
  RISK
}

enum InsightSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

// Benchmarks model
model Benchmark {
  id           String    @id @default(uuid())

  industry     String
  companySize  String    @map("company_size")
  growthStage  String?   @map("growth_stage")
  region       String?

  metrics      Json

  source       String
  sampleSize   Int?      @map("sample_size")

  version      Int       @default(1)
  active       Boolean   @default(true)

  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @updatedAt @map("updated_at")

  @@index([industry, companySize])
  @@index([active])
  @@map("benchmarks")
}

// Department mapping for standardization
model DepartmentMapping {
  id                String   @id @default(uuid())
  userId            String?  @map("user_id")  // Optional: for user-specific mappings

  originalName      String   @map("original_name")
  standardizedName  String   @map("standardized_name")
  category          String?  // e.g., "Technology", "Business", "Operations"

  isActive          Boolean  @default(true) @map("is_active")
  usageCount        Int      @default(0) @map("usage_count")  // Track how often this mapping is used

  createdAt         DateTime @default(now()) @map("created_at")
  updatedAt         DateTime @updatedAt @map("updated_at")

  @@unique([userId, originalName])
  @@index([standardizedName])
  @@index([category])
  @@map("department_mappings")
}

// Role mapping for standardization
model RoleMapping {
  id                String   @id @default(uuid())
  userId            String?  @map("user_id")  // Optional: for user-specific mappings

  originalTitle     String   @map("original_title")
  standardizedTitle String   @map("standardized_title")
  seniorityLevel    String?  @map("seniority_level")  // "Junior", "Mid", "Senior", "Lead", "Director", "C-Level"
  roleFamily        String?  @map("role_family")      // "Engineering", "Sales", "Marketing", etc.

  isActive          Boolean  @default(true) @map("is_active")
  usageCount        Int      @default(0) @map("usage_count")
  confidenceScore   Decimal? @map("confidence_score") @db.Decimal(3, 2)  // 0.00 to 1.00

  createdAt         DateTime @default(now()) @map("created_at")
  updatedAt         DateTime @updatedAt @map("updated_at")

  @@unique([userId, originalTitle])
  @@index([standardizedTitle, seniorityLevel])
  @@index([roleFamily])
  @@map("role_mappings")
}

// Role Title Library - customer-driven role title learning
model RoleTitleLibrary {
  id                String   @id @default(uuid())

  // Raw data from customers
  originalTitle     String   @unique @map("original_title")  // "Senior Fullstack Engineer"

  // Normalized/standardized data
  standardizedTitle String   @map("standardized_title")       // "Software Engineer"
  seniorityLevel    String?  @map("seniority_level")          // "Senior"
  roleFamily        String?  @map("role_family")              // "Engineering"

  // Usage tracking
  frequency         Int      @default(1)                      // How many times we've seen this exact title
  firstSeenDate     DateTime @default(now()) @map("first_seen_date")
  lastSeenDate      DateTime @updatedAt @map("last_seen_date")

  // Context for better matching (stored as arrays)
  industries        String[] @default([])                    // ["SaaS", "Fintech", "Climate Tech"]
  regions           String[] @default([])                    // ["EU", "US", "DACH"]
  companySizes      String[] @default([])                    // ["51-200", "201-500"]

  // Quality indicators
  verifiedByUsers   Int      @default(0) @map("verified_by_users")  // How many users confirmed this mapping
  reportedIssues    Int      @default(0) @map("reported_issues")    // How many users reported wrong mapping

  createdAt         DateTime @default(now()) @map("created_at")
  updatedAt         DateTime @updatedAt @map("updated_at")

  @@index([standardizedTitle, seniorityLevel])
  @@index([roleFamily])
  @@index([frequency(sort: Desc)])
  @@map("role_title_library")
}

// Compensation Benchmark - crowdsourced salary data
model CompensationBenchmark {
  id                String   @id @default(uuid())

  // Role identification
  roleFamily        String   @map("role_family")              // "Engineering"
  standardizedTitle String   @map("standardized_title")       // "Software Engineer"
  seniorityLevel    String   @map("seniority_level")          // "Senior"

  // Market segmentation
  industry          String                                    // "SaaS", "Fintech", "Climate Tech"
  region            String                                    // "DACH", "EU", "US"
  companySize       String   @map("company_size")             // "51-200", "201-500"

  // Percentile data for total compensation (anonymized)
  p10TotalComp      Decimal? @map("p10_total_comp") @db.Decimal(12, 2)
  p25TotalComp      Decimal? @map("p25_total_comp") @db.Decimal(12, 2)
  p50TotalComp      Decimal? @map("p50_total_comp") @db.Decimal(12, 2)  // Median
  p75TotalComp      Decimal? @map("p75_total_comp") @db.Decimal(12, 2)
  p90TotalComp      Decimal? @map("p90_total_comp") @db.Decimal(12, 2)

  // Percentile data for base salary (anonymized)
  p10BaseSalary     Decimal? @map("p10_base_salary") @db.Decimal(12, 2)
  p25BaseSalary     Decimal? @map("p25_base_salary") @db.Decimal(12, 2)
  p50BaseSalary     Decimal? @map("p50_base_salary") @db.Decimal(12, 2)
  p75BaseSalary     Decimal? @map("p75_base_salary") @db.Decimal(12, 2)
  p90BaseSalary     Decimal? @map("p90_base_salary") @db.Decimal(12, 2)

  // Quality indicators
  sampleSize        Int                                       // 127 data points
  currency          String                                    // "EUR", "USD"
  lastUpdated       DateTime @updatedAt @map("last_updated")

  // Data lineage
  dataSource        String   @default("customer_crowdsourced") @map("data_source")

  createdAt         DateTime @default(now()) @map("created_at")
  updatedAt         DateTime @updatedAt @map("updated_at")

  @@unique([roleFamily, standardizedTitle, seniorityLevel, industry, region, companySize])
  @@index([roleFamily, seniorityLevel])
  @@index([industry, region])
  @@map("compensation_benchmarks")
}

// Role Taxonomy - static foundation for role families
model RoleTaxonomy {
  id             String   @id @default(uuid())

  roleFamily     String   @map("role_family")        // "Engineering", "Sales", "Product"
  roleTitle      String   @map("role_title")         // "Software Engineer", "Account Executive"
  seniorityLevel String   @map("seniority_level")    // "IC1", "IC2", "IC3", "Manager", "Director"
  aliases        String[] @default([])               // Common variations for seeding
  description    String?

  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @updatedAt @map("updated_at")

  @@unique([roleFamily, roleTitle, seniorityLevel])
  @@index([roleFamily])
  @@map("role_taxonomy")
}

// Organizational Benchmarks - structural and efficiency metrics
model OrganizationalBenchmark {
  id              String   @id @default(uuid())

  // Market segmentation
  industry        String
  region          String
  companySize     String   @map("company_size")
  growthStage     String?  @map("growth_stage")  // "Seed", "Series A", "Series B+", "Public"

  // Entry mode (determines data structure)
  entryMode       BenchmarkEntryMode @default(FALLBACK) @map("entry_mode")  // DETAILED or FALLBACK

  // === DETAILED MODE: Raw department headcount data ===
  // Percentile-based department breakdown (JSON)
  // Uses standard department categories to match user data structure
  // Categories: R&D, GTM (Go-to-Market), G&A (General & Administrative), Operations, Other
  // Example structure:
  // {
  //   "p10": { "rd": 15, "gtm": 13, "ga": 8, "operations": 3, "other": 1, "total": 40 },
  //   "p25": { "rd": 27, "gtm": 19, "ga": 10, "operations": 3, "other": 1, "total": 60 },
  //   "p50": { "rd": 43, "gtm": 30, "ga": 16, "operations": 5, "other": 2, "total": 96 },
  //   "p75": { "rd": 64, "gtm": 46, "ga": 24, "operations": 7, "other": 3, "total": 144 },
  //   "p90": { "rd": 86, "gtm": 63, "ga": 32, "operations": 10, "other": 4, "total": 195 }
  // }
  // This allows direct comparison with user data which uses the same categories via DatasetSettings.departmentCategories
  departmentHeadcount Json? @map("department_headcount")

  // === FALLBACK MODE: Pre-calculated metric values ===
  // Used when detailed department data is not available
  benchmarkType   BenchmarkType? @map("benchmark_type")  // STRUCTURE, EFFICIENCY, TENURE
  metricName      String?   @map("metric_name")          // "rd_to_gtm_ratio", "revenue_per_fte", etc.

  // Percentile data for the specific metric
  p10Value        Decimal? @map("p10_value") @db.Decimal(12, 2)
  p25Value        Decimal? @map("p25_value") @db.Decimal(12, 2)
  p50Value        Decimal? @map("p50_value") @db.Decimal(12, 2)  // Median
  p75Value        Decimal? @map("p75_value") @db.Decimal(12, 2)
  p90Value        Decimal? @map("p90_value") @db.Decimal(12, 2)

  // === EFFICIENCY METRICS (for both modes) ===
  // Revenue data (optional, for efficiency benchmarks)
  revenueData     Json?    @map("revenue_data")
  // Example: { "p10": 4800000, "p25": 7200000, "p50": 12000000, "p75": 18000000, "p90": 25000000 }

  // === SHARED METADATA ===
  // Data quality and lineage
  sampleSize      Int                                    // Number of companies in sample
  currency        String?                                // For monetary metrics
  unit            String?                                // "ratio", "percentage", "euros", "days", etc.
  sourceId        String?  @map("source_id")             // FK to BenchmarkSource
  source          BenchmarkSource? @relation(fields: [sourceId], references: [id])

  // Temporal validity
  effectiveDate   DateTime @map("effective_date")        // When this benchmark becomes valid
  expirationDate  DateTime? @map("expiration_date")      // When this benchmark expires (optional)
  lastVerified    DateTime @default(now()) @map("last_verified")

  // Approval workflow
  approvalStatus  BenchmarkApprovalStatus @default(PENDING) @map("approval_status")
  approvedBy      String?  @map("approved_by")           // Admin user ID who approved
  approvedAt      DateTime? @map("approved_at")
  rejectionReason String?  @map("rejection_reason")      // Why it was rejected

  // Metadata
  notes           String?
  methodology     String?                                // Brief description of how data was collected

  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  @@unique([industry, region, companySize, entryMode, benchmarkType, metricName, effectiveDate])
  @@index([industry, region, companySize])
  @@index([benchmarkType, metricName])
  @@index([effectiveDate, expirationDate])
  @@index([sourceId])
  @@index([entryMode])
  @@index([approvalStatus])
  @@map("organizational_benchmarks")
}

enum BenchmarkEntryMode {
  DETAILED       // Raw department headcount data (preferred)
  FALLBACK       // Pre-calculated metrics only
}

enum BenchmarkType {
  STRUCTURE      // rd_to_gtm_ratio, manager_to_ic_ratio, span_of_control, dept_distribution
  EFFICIENCY     // revenue_per_fte, cost_per_fte, revenue_per_sales_fte, gross_margin
  TENURE         // avg_tenure, retention_rate, time_to_promotion, new_hire_retention
}

enum BenchmarkApprovalStatus {
  PENDING        // Awaiting admin review
  APPROVED       // Approved for use in benchmarks
  REJECTED       // Rejected, will not be used
}

// Benchmark Source - track third-party data providers
model BenchmarkSource {
  id              String   @id @default(uuid())

  name            String   @unique                       // "Pave", "Radford", "Manual Entry", "Customer Crowdsourced"
  type            SourceType                            // THIRD_PARTY, MANUAL, CROWDSOURCED
  website         String?
  contactEmail    String?  @map("contact_email")
  description     String?

  // Licensing and access
  licenseType     String?  @map("license_type")          // "Paid", "Free", "Partnership"
  accessNotes     String?  @map("access_notes")
  lastContacted   DateTime? @map("last_contacted")

  // Quality indicators
  reliability     String?                                // "High", "Medium", "Low"
  updateFrequency String?  @map("update_frequency")      // "Quarterly", "Annual", "Ad-hoc"

  isActive        Boolean  @default(true) @map("is_active")

  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  // Relations
  organizationalBenchmarks OrganizationalBenchmark[]
  auditLogs       BenchmarkAuditLog[]

  @@index([type])
  @@index([isActive])
  @@map("benchmark_sources")
}

enum SourceType {
  THIRD_PARTY    // Pave, Radford, etc.
  MANUAL         // Admin-entered data
  CROWDSOURCED   // Aggregated from customer data
}

// Benchmark Audit Log - track all changes to benchmark data
model BenchmarkAuditLog {
  id              String   @id @default(uuid())

  // What was changed
  resourceType    String   @map("resource_type")         // "OrganizationalBenchmark", "CompensationBenchmark"
  resourceId      String   @map("resource_id")
  action          String                                 // "CREATE", "UPDATE", "DELETE", "VERIFY"

  // Who changed it
  userId          String?  @map("user_id")               // Admin user who made the change
  sourceId        String?  @map("source_id")
  source          BenchmarkSource? @relation(fields: [sourceId], references: [id])

  // Change details
  previousData    Json?    @map("previous_data")         // Snapshot before change
  newData         Json?    @map("new_data")              // Snapshot after change
  changeReason    String?  @map("change_reason")         // Why this change was made

  // Context
  ipAddress       String?  @map("ip_address")
  userAgent       String?  @map("user_agent")

  createdAt       DateTime @default(now()) @map("created_at")

  @@index([resourceType, resourceId])
  @@index([userId])
  @@index([sourceId])
  @@index([action])
  @@index([createdAt(sort: Desc)])
  @@map("benchmark_audit_logs")
}

// Monthly Employer Costs - Track actual employer costs over time
model MonthlyEmployerCost {
  id           String    @id @default(uuid())
  datasetId    String    @map("dataset_id")

  // Period tracking
  period       DateTime                             // First day of the month (e.g., 2025-01-01)
  periodLabel  String    @map("period_label")       // Human-readable "January 2025"

  // Scope: employee-specific or dataset-wide aggregate
  employeeId   String?   @map("employee_id")        // NULL for aggregated data
  department   String?                              // Department (copied from employee or aggregated)

  // Gross compensation (what employee receives)
  grossSalary  Decimal   @map("gross_salary") @db.Decimal(12, 2)
  grossBonus   Decimal?  @map("gross_bonus") @db.Decimal(12, 2)
  grossEquity  Decimal?  @map("gross_equity") @db.Decimal(12, 2)
  grossTotal   Decimal   @map("gross_total") @db.Decimal(12, 2)

  // Employer costs (what company pays)
  employerTaxes         Decimal? @map("employer_taxes") @db.Decimal(12, 2)          // Employer-side taxes
  socialContributions   Decimal? @map("social_contributions") @db.Decimal(12, 2)    // Social security, pension, etc.
  healthInsurance       Decimal? @map("health_insurance") @db.Decimal(12, 2)        // Health insurance contributions
  benefits              Decimal? @map("benefits") @db.Decimal(12, 2)                // Other benefits (gym, meals, etc.)
  otherEmployerCosts    Decimal? @map("other_employer_costs") @db.Decimal(12, 2)    // Training, equipment, etc.

  // Total employer cost
  totalEmployerCost     Decimal  @map("total_employer_cost") @db.Decimal(12, 2)     // Sum of all above

  // Metrics
  employerCostRatio     Decimal? @map("employer_cost_ratio") @db.Decimal(5, 2)      // Total employer cost / Gross total (e.g., 1.35 = 35% overhead)

  // Data source tracking
  source                CostDataSource @default(MANUAL)                              // How was this data added
  importedFrom          String?  @map("imported_from")                               // File name or API source

  // Metadata
  notes                 String?
  currency              String   @default("EUR")

  createdAt             DateTime @default(now()) @map("created_at")
  updatedAt             DateTime @updatedAt @map("updated_at")

  // Relations
  dataset               Dataset  @relation(fields: [datasetId], references: [id], onDelete: Cascade)
  employee              Employee? @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  @@unique([datasetId, period, employeeId])  // One record per employee per month
  @@index([datasetId, period])
  @@index([datasetId, period, department])
  @@index([employeeId])
  @@index([source])
  @@map("monthly_employer_costs")
}

enum CostDataSource {
  MANUAL         // Manually entered by user
  CSV_IMPORT     // Imported from payroll CSV
  API_IMPORT     // Imported via API (future)
  CALCULATED     // Calculated from employee data
}

// Monthly Planned Compensation - Track planned/budgeted compensation over time
model MonthlyPlannedCompensation {
  id           String    @id @default(uuid())
  datasetId    String    @map("dataset_id")

  // Period tracking
  period       DateTime                             // First day of the month (e.g., 2025-01-01)
  periodLabel  String    @map("period_label")       // Human-readable "January 2025"

  // Employee reference
  employeeId   String    @map("employee_id")

  // Planned gross compensation (what employee should receive)
  plannedGrossSalary  Decimal   @map("planned_gross_salary") @db.Decimal(12, 2)
  plannedGrossBonus   Decimal?  @map("planned_gross_bonus") @db.Decimal(12, 2)
  plannedGrossEquity  Decimal?  @map("planned_gross_equity") @db.Decimal(12, 2)
  plannedGrossTotal   Decimal   @map("planned_gross_total") @db.Decimal(12, 2)

  // Planned employer costs (what company expects to pay)
  plannedEmployerTaxes         Decimal? @map("planned_employer_taxes") @db.Decimal(12, 2)
  plannedSocialContributions   Decimal? @map("planned_social_contributions") @db.Decimal(12, 2)
  plannedHealthInsurance       Decimal? @map("planned_health_insurance") @db.Decimal(12, 2)
  plannedBenefits              Decimal? @map("planned_benefits") @db.Decimal(12, 2)
  plannedOtherEmployerCosts    Decimal? @map("planned_other_employer_costs") @db.Decimal(12, 2)

  // Total planned employer cost
  plannedTotalEmployerCost     Decimal  @map("planned_total_employer_cost") @db.Decimal(12, 2)

  // Metadata
  isManualOverride  Boolean  @default(false) @map("is_manual_override")  // True if manually edited, false if auto-calculated
  notes             String?
  currency          String   @default("EUR")

  createdAt         DateTime @default(now()) @map("created_at")
  updatedAt         DateTime @updatedAt @map("updated_at")

  // Relations
  dataset           Dataset  @relation(fields: [datasetId], references: [id], onDelete: Cascade)
  employee          Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  @@unique([datasetId, period, employeeId])  // One planned record per employee per month
  @@index([datasetId, period])
  @@index([employeeId])
  @@index([isManualOverride])
  @@map("monthly_planned_compensation")
}

// Monthly Revenue - Track actual revenue over time for burn vs revenue analysis
model MonthlyRevenue {
  id           String    @id @default(uuid())
  datasetId    String    @map("dataset_id")

  // Period tracking
  period       DateTime                             // First day of the month (e.g., 2025-01-01)
  periodLabel  String    @map("period_label")       // Human-readable "January 2025"

  // Revenue data
  revenue      Decimal   @db.Decimal(15, 2)         // Total revenue for the month

  // Data source tracking
  source       CostDataSource @default(MANUAL)      // How was this data added
  importedFrom String?  @map("imported_from")       // File name or API source

  // Metadata
  notes        String?
  currency     String   @default("EUR")

  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  // Relations
  dataset      Dataset  @relation(fields: [datasetId], references: [id], onDelete: Cascade)

  @@unique([datasetId, period])  // One revenue record per dataset per month
  @@index([datasetId, period])
  @@index([source])
  @@map("monthly_revenue")
}

// Compensation Scenario - for IS/SHOULD/FORECAST planning
model CompensationScenario {
  id          String   @id @default(uuid())
  datasetId   String   @map("dataset_id")

  name        String                              // "Baseline", "Planned", "Q1 Raises", etc.
  description String?

  isBaseline  Boolean  @default(false) @map("is_baseline")  // Only one baseline per dataset
  isActive    Boolean  @default(true) @map("is_active")

  status      CompensationScenarioStatus @default(DRAFT)
  approvedBy  String?  @map("approved_by")
  approvedAt  DateTime? @map("approved_at")

  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  dataset     Dataset  @relation(fields: [datasetId], references: [id], onDelete: Cascade)
  targets     EmployeeCompensationTarget[]

  @@index([datasetId])
  @@index([isBaseline])
  @@index([status])
  @@map("compensation_scenarios")
}

enum CompensationScenarioStatus {
  DRAFT
  APPROVED
  ARCHIVED
}

// Employee Compensation Target - stores SHOULD values
model EmployeeCompensationTarget {
  id           String   @id @default(uuid())
  employeeId   String   @map("employee_id")
  scenarioId   String?  @map("scenario_id")  // NULL for default/baseline

  // SHOULD value
  targetAnnualComp  Decimal  @map("target_annual_comp") @db.Decimal(12, 2)

  // How was this target calculated
  calculationMethod String  @map("calculation_method")  // "benchmark", "manual", "formula"
  benchmarkSource   String? @map("benchmark_source")    // Which benchmark was used

  // Manual override
  isManualOverride  Boolean @default(false) @map("is_manual_override")
  overrideReason    String? @map("override_reason")

  // Explanation data (JSON)
  // Structure: { marketBenchmark: 150000, locationAdjustment: 1.1, performanceFactor: 1.0, ... }
  explanation  Json?  // Breakdown showing how target was calculated

  // Target timeline
  targetDate   DateTime? @map("target_date")  // When should employee reach this comp

  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  // Relations
  employee     Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  scenario     CompensationScenario? @relation(fields: [scenarioId], references: [id], onDelete: Cascade)

  @@unique([employeeId, scenarioId])
  @@index([employeeId])
  @@index([scenarioId])
  @@index([calculationMethod])
  @@map("employee_compensation_targets")
}

// Audit logs
model AuditLog {
  id           String    @id @default(uuid())
  userId       String?   @map("user_id")

  action       String
  resourceType String?   @map("resource_type")
  resourceId   String?   @map("resource_id")

  metadata     Json?
  ipAddress    String?   @map("ip_address")
  userAgent    String?   @map("user_agent")

  createdAt    DateTime  @default(now()) @map("created_at")

  @@index([userId])
  @@index([action])
  @@index([createdAt(sort: Desc)])
  @@map("audit_logs")
}
